To simulate message losses, we simply generate a random number each time before establishing the unicast connection, in other words, before opening the "DatagramChannel". For example, if the drop rate given to a specific process is 30%, then we generate an integer from 1 to 100, and the unicast will only be performed if the generated value is greater than 30.

To simulate message delay, we simply generate a random number each time before writing message into "DatagramChannel". For a given mean delay, the delay time will be generated randomly in range of [0, 2*mean delay], and let the sending thread to sleep this amount of time.

For causal ordering, we used an array recent to keep track of the most recent message received from each process. The value for each field is the messageID, which is unique for each process. When reading a message from stdin, the recent array in the message is assigned with the value of the recent array of the process, so that the message contains the recent received message information of the sender process. And when sending out a message, the recent array is also send out with the message. When a process receive the message, it compares it's recent array with the message's recent array. If every element of the recent array of the process is larger than the message's recent, meaning this process has delivered every message that has been delivered at the sender just prior to sending this message, which is the requirement, then this process delivers this message. Otherwise, it puts the message in a queue. And then it check the message in the queue, if the elements satisfies causal ordering, dequeue it and deliver it. And do so until the queue is empty.

For total ordering, the algorithm we were using is to designate a process, in our case, P0, as the sequencer. Each time a message being multicasted, the message will be sent to P0 as well. And P0 will generate a special kind of message, in our program, called "OrderMessage", which contains both the original message and the a unique order from 0. Increment the order by 1 every time a new OrderMessage has been created. This OrderMessage will then be multicasted, processes receiving the message will first put it into a hold-back queue, in our program, a priority queue, sorted by minimum order number. Each process has a variable "currOrder", starting from 0, to keep track of the current valid order. Keep checking peek of the priority queue, once the order of the message at the peek matches "currOrder", this message will be allowed to deliver.